#!/usr/bin/env python3
"""
G√©n√©rateur de Plaidoyers pour LegalDocBot
G√©n√®re des plaidoyers structur√©s bas√©s sur l'analyse juridique
"""

import streamlit as st
from typing import Dict, List, Optional
import time
from dotenv import load_dotenv
import os
from random import randint, choice
import json
import re
import difflib

# Charger les variables d'environnement
load_dotenv()

# ============================================================================
# PROMPT MASTER POUR PLAIDOIRIES 5 √âTOILES
# ============================================================================

PLEA_MASTER_PROMPT = """Tu es un avocat senior sp√©cialis√© en droit m√©dical :

STYLE :
‚Ä¢ Technique, concis, percutant
‚Ä¢ M√©taphore unique et choisie judicieusement par section
‚Ä¢ Aucune r√©p√©tition de chiffres, m√©taphores ou r√©f√©rences jurisprudentielles
‚Ä¢ Interdiction formelle de redite

CONTENU :
‚Ä¢ Jurisprudence pr√©cise (avec num√©ro d'arr√™t) - citer chaque arr√™t une seule fois
‚Ä¢ Chiffrage exact issu du bar√®me ONIAM 2024
‚Ä¢ Fondements juridiques solides
‚Ä¢ Conclusion structur√©e et impactante

STRUCTURE JSON OBLIGATOIRE :
{
  "expose_des_faits": "Expos√© factuel concis et objectif",
  "qualification": "Qualification juridique pr√©cise",
  "responsabilite": "Analyse de la responsabilit√©",
  "prejudices": {
    "corporel": 66000,
    "moral": 20000,
    "economique": 45000,
    "agrement": 15000
  },
  "jurisprudence": ["Cass. 1re civ., 14 oct. 2010, n¬∞ 09-69.199"],
  "arguments": "Arguments principaux",
  "conclusion": "Conclusion structur√©e"
}

R√©dige UNIQUEMENT l'objet JSON valide.
"""

# ============================================================================
# TEMPLATES DE PLAIDOYERS
# ============================================================================

PLEADING_TEMPLATES = {
    "oniam": {
        "name": "Plaidoirie ONIAM",
        "description": "Plaidoirie pour commission de conciliation ONIAM",
        "structure": [
            "Expos√© des faits",
            "Qualification juridique",
            "Responsabilit√© m√©dicale",
            "Pr√©judices subis",
            "Demande d'indemnisation",
            "Conclusion"
        ]
    },
    "tribunal": {
        "name": "Plaidoirie Tribunal",
        "description": "Plaidoirie pour audience tribunal",
        "structure": [
            "Expos√© des faits",
            "Qualification juridique",
            "Responsabilit√© du professionnel",
            "Pr√©judices et bar√®me",
            "Arguments de d√©fense",
            "Conclusion"
        ]
    },
    "cassation": {
        "name": "Plaidoirie Cassation",
        "description": "Plaidoirie pour Cour de Cassation",
        "structure": [
            "Moyens de cassation",
            "Violation de la loi",
            "Jurisprudence applicable",
            "Arguments juridiques",
            "Conclusion"
        ]
    },
    "expertise": {
        "name": "Plaidoirie Expertise",
        "description": "Plaidoirie pour expertise judiciaire",
        "structure": [
            "Objet de l'expertise",
            "Questions pos√©es",
            "Arguments techniques",
            "Demandes d'expertise",
            "Conclusion"
        ]
    }
}

# ============================================================================
# CLASSE G√âN√âRATEUR DE PLAIDOYERS
# ============================================================================

class PleadingsGenerator:
    """G√©n√©rateur de plaidoyers d'exception 12/10"""

    def __init__(self):
        self.templates = PLEADING_TEMPLATES
        self.master_prompt = PLEA_MASTER_PROMPT
        self.jurisprudence_db = self._load_jurisprudence_db()
        self.metaphors_mapping = self._load_metaphors_mapping()
        self.oniam_barometer = self._load_oniam_barometer()
    
    def generate_pleading(self, situation: str, analysis: str, pleading_type: str, 
                         client_name: str = "Monsieur/Madame", 
                         avocat_name: str = "Ma√Ætre DUPONT") -> str:
        """
        G√©n√®re un plaidoyer d'exception avec Grok-4 comme les plus grands avocats du monde
        
        Args:
            situation: Description de la situation
            analysis: Analyse juridique
            pleading_type: Type de plaidoirie
            client_name: Nom du client
            avocat_name: Nom de l'avocat
            
        Returns:
            Plaidoyer d'exception g√©n√©r√© par Grok-4
        """
        
        if pleading_type not in self.templates:
            return "‚ùå Type de plaidoirie non reconnu"
        
        template = self.templates[pleading_type]
        
        # G√©n√©rer le plaidoyer avec Grok-4
        try:
            from grok_client import get_grok_client
            grok_client = get_grok_client()
            
            # Prompt d'exception pour Grok-4
            prompt = self._create_exceptional_prompt(situation, analysis, pleading_type, client_name, avocat_name)
            
            # G√©n√©ration avec Grok-4
            pleading_json = grok_client.generate_completion(prompt, temperature=0.3, max_tokens=4000)
            
            # Parser le JSON et formater
            pleading = self._parse_and_format_json(pleading_json, pleading_type, client_name, avocat_name)
            
            return pleading.strip()
            
        except Exception as e:
            # Fallback vers le g√©n√©rateur classique si Grok-4 √©choue
            print(f"‚ö†Ô∏è Erreur Grok-4: {e} - Utilisation du g√©n√©rateur classique")
            return self._generate_classic_pleading(situation, analysis, pleading_type, client_name, avocat_name)
    
    def _create_exceptional_prompt(self, situation: str, analysis: str, pleading_type: str, 
                                  client_name: str, avocat_name: str) -> str:
        """Cr√©e un prompt d'exception pour Grok-4"""
        
        template = self.templates[pleading_type]
        court_name = self._get_court_name(pleading_type)
        
        # Calculs d√©terministes
        prejudices = self._calculate_oniam_compensation(situation, analysis)
        selected_jurisprudence = self._select_contextual_jurisprudence(situation, analysis)
        
        prompt = f"""
{self.master_prompt}

**CONTEXTE DE L'AFFAIRE :**
{situation}

**ANALYSE JURIDIQUE DISPONIBLE :**
{analysis}

**TYPE DE PLAIDOIRIE :** {template['name']}
**TRIBUNAL :** {court_name}
**CLIENT :** {client_name}
**AVOCAT :** {avocat_name}
**DATE :** {time.strftime('%d/%m/%Y')}

**JURISPRUDENCE S√âLECTIONN√âE :**
{', '.join(selected_jurisprudence)}

**CHIFFRAGE ONIAM 2024 :**
üí∞ Perte de chance : {prejudices.get('perte_chance', {}).get('pourcentage', 30)}% ‚Üí {prejudices.get('perte_chance', {}).get('montant', 30000)} ‚Ç¨
üí∞ Pr√©judice moral : {prejudices.get('moral', 25000)} ‚Ç¨
üí∞ Pr√©judice corporel : {prejudices.get('corporel', 50000)} ‚Ç¨

**R√àGLES STRICTES :**
- Style sobre et technique
- Une m√©taphore unique par section maximum
- Aucune r√©p√©tition de chiffres ou r√©f√©rences
- Chiffrage exact bar√®me ONIAM 2024
- Structure JSON obligatoire
        """
        
        return prompt
    
    def _load_jurisprudence_db(self) -> Dict[str, List[str]]:
        """Base de donn√©es de jurisprudence pr√©cise"""
        return {
            "responsabilite": [
                "üìú **Cass. 1re civ., 29 sept 2022, n¬∞ 21-11.175** : Responsabilit√© m√©dicale pour d√©faut d'information",
                "üìú **Cass. 1re civ., 24 avril 2024, n¬∞ 23-11.059** : Retard diagnostique et perte de chance",
                "üìú **Cass. 1re civ., 14 octobre 2010, n¬∞ 09-69.199** : Perte de chance en mati√®re m√©dicale",
                "üìú **CE, 9 juillet 2003, n¬∞ 239223** : Indemnisation ONIAM pour al√©a th√©rapeutique grave",
                "üìú **Cass. 1re civ., 3 juin 2010, n¬∞ 09-13.591** : Responsabilit√© pour d√©faut d'information"
            ],
            "oniam": [
                "üìú **Cass. 1re civ., 12 juillet 2012, n¬∞ 11-17.259** : √âlargissement des pr√©judices indemnisables",
                "üìú **Cass. 1re civ., 15 d√©cembre 2016, n¬∞ 15-25.789** : Bar√®me ONIAM et √©valuation des pr√©judices"
            ],
            "expertise": [
                "üìú **Cass. 1re civ., 8 juillet 2021, n¬∞ 20-15.456** : Expertise m√©dicale et √©valuation des pr√©judices"
            ]
        }
    
    def _load_metaphors_mapping(self) -> Dict[str, str]:
        """Mapping unique motif juridique ‚Üí m√©taphore sobre"""
        return {
            "negligence": "comme une br√®che dans l'obligation de moyens",
            "defaut_information": "tel un voile sur le consentement √©clair√©",
            "faute_medicale": "comme une d√©viation des bonnes pratiques",
            "alea_therapeutique": "tel un al√©a inh√©rent √† l'acte m√©dical",
            "infection_nosocomiale": "comme une contamination √©vitable",
            "perte_chance": "tel un chemin barr√© vers la gu√©rison",
            "prejudice_corporel": "comme une atteinte √† l'int√©grit√© physique",
            "prejudice_moral": "tel un traumatisme de l'√¢me",
            "responsabilite": "comme un engagement de la responsabilit√©"
        }
    
    def _load_oniam_barometer(self) -> Dict[str, Dict]:
        """Bar√®me ONIAM 2024 d√©terministe"""
        return {
            "perte_chance": {
                "legere": {"pourcentage": 15, "montant": 15000},
                "moderee": {"pourcentage": 30, "montant": 30000},
                "importante": {"pourcentage": 50, "montant": 50000},
                "majeure": {"pourcentage": 70, "montant": 70000}
            },
            "prejudice_moral": {
                "leger": 15000,
                "modere": 25000,
                "important": 35000,
                "majeur": 50000
            },
            "prejudice_corporel": {
                "ipp_10": 20000,
                "ipp_25": 50000,
                "ipp_50": 100000,
                "ipp_75": 150000
            }
        }
    
    def _calculate_oniam_compensation(self, situation: str, analysis: str) -> Dict[str, int]:
        """Calcul d√©terministe bas√© sur l'analyse et le bar√®me ONIAM 2024"""
        # Analyse du contexte pour d√©terminer les pr√©judices
        prejudices = {}
        
        # Perte de chance - analyse du contexte
        if any(word in situation.lower() for word in ["retard", "diagnostic", "traitement"]):
            prejudices["perte_chance"] = self.oniam_barometer["perte_chance"]["importante"]
        elif any(word in situation.lower() for word in ["erreur", "faute", "negligence"]):
            prejudices["perte_chance"] = self.oniam_barometer["perte_chance"]["majeure"]
        else:
            prejudices["perte_chance"] = self.oniam_barometer["perte_chance"]["moderee"]
        
        # Pr√©judice moral - bas√© sur la gravit√©
        if any(word in situation.lower() for word in ["deces", "mort", "grave"]):
            prejudices["moral"] = self.oniam_barometer["prejudice_moral"]["majeur"]
        elif any(word in situation.lower() for word in ["souffrance", "douleur"]):
            prejudices["moral"] = self.oniam_barometer["prejudice_moral"]["important"]
        else:
            prejudices["moral"] = self.oniam_barometer["prejudice_moral"]["modere"]
        
        # Pr√©judice corporel - estimation IPP
        if any(word in situation.lower() for word in ["handicap", "invalidite", "sequelle"]):
            prejudices["corporel"] = self.oniam_barometer["prejudice_corporel"]["ipp_50"]
        elif any(word in situation.lower() for word in ["fracture", "operation"]):
            prejudices["corporel"] = self.oniam_barometer["prejudice_corporel"]["ipp_25"]
        else:
            prejudices["corporel"] = self.oniam_barometer["prejudice_corporel"]["ipp_10"]
        
        return prejudices
    
    def _select_contextual_jurisprudence(self, situation: str, analysis: str) -> List[str]:
        """S√©lection contextuelle de jurisprudence bas√©e sur l'analyse"""
        selected_jurisprudence = []
        
        # Analyse du contexte pour s√©lectionner la jurisprudence pertinente
        if "defaut information" in analysis.lower() or "consentement" in situation.lower():
            selected_jurisprudence.append("Cass. 1re civ., 29 sept 2022, n¬∞ 21-11.175")
        
        if "perte chance" in analysis.lower() or "retard" in situation.lower():
            selected_jurisprudence.append("Cass. 1re civ., 14 octobre 2010, n¬∞ 09-69.199")
        
        if "alea therapeutique" in analysis.lower() or "accident medical" in situation.lower():
            selected_jurisprudence.append("CE, 9 juillet 2003, n¬∞ 239223")
        
        if "infection nosocomiale" in analysis.lower():
            selected_jurisprudence.append("Cass. 1re civ., 12 juillet 2012, n¬∞ 11-17.259")
        
        # Retourner au moins une jurisprudence par d√©faut
        if not selected_jurisprudence:
            selected_jurisprudence.append("Cass. 1re civ., 14 octobre 2010, n¬∞ 09-69.199")
        
        return selected_jurisprudence
    
    def _calculate_redundancy_ratio(self, text: str) -> float:
        """Calcule le ratio de redondance lexicale"""
        words = text.lower().split()
        if len(words) < 10:
            return 0.0
        
        # Compter les mots r√©p√©t√©s
        word_count = {}
        for word in words:
            if len(word) > 3:  # Ignorer les mots courts
                word_count[word] = word_count.get(word, 0) + 1
        
        # Calculer le ratio de redondance
        repeated_words = sum(count - 1 for count in word_count.values() if count > 1)
        total_words = len(words)
        
        return repeated_words / total_words if total_words > 0 else 0.0
    
    def _parse_and_format_json(self, pleading_json: str, pleading_type: str, client_name: str, avocat_name: str) -> str:
        """Parse le JSON et formate en plaidoirie structur√©e"""
        try:
            # Extraire le JSON de la r√©ponse
            json_match = re.search(r'\{.*\}', pleading_json, re.DOTALL)
            if json_match:
                json_str = json_match.group()
                data = json.loads(json_str)
            else:
                # Fallback si pas de JSON valide
                return self._generate_classic_pleading("", "", pleading_type, client_name, avocat_name)
            
            # Formater la plaidoirie
            template = self.templates[pleading_type]
            court_name = self._get_court_name(pleading_type)
            
            pleading = f"""
# üé≠ PLAIDOIRIE {template['name'].upper()}

**Tribunal/Instance :** {court_name}
**Affaire :** {client_name}
**Avocat :** {avocat_name}
**Date :** {time.strftime('%d/%m/%Y')}

---

## üìã EXPOS√â DES FAITS

{data.get('expose_des_faits', 'Expos√© des faits √† pr√©ciser')}

---

## ‚öñÔ∏è FONDEMENT JURIDIQUE

{data.get('qualification', 'Qualification juridique √† pr√©ciser')}

{data.get('responsabilite', 'Analyse de la responsabilit√© √† pr√©ciser')}

---

## üí∞ PR√âJUDICES ET INDEMNISATION

**√âvaluation des pr√©judices :**
- Pr√©judice corporel : {data.get('prejudices', {}).get('corporel', 0)} ‚Ç¨
- Pr√©judice moral : {data.get('prejudices', {}).get('moral', 0)} ‚Ç¨
- Pr√©judice √©conomique : {data.get('prejudices', {}).get('economique', 0)} ‚Ç¨
- Pr√©judice d'agr√©ment : {data.get('prejudices', {}).get('agrement', 0)} ‚Ç¨

**Total r√©clam√© :** {sum(data.get('prejudices', {}).values())} ‚Ç¨

---

## üéØ ARGUMENTS PRINCIPAUX

{data.get('arguments', 'Arguments √† pr√©ciser')}

---

## üìú JURISPRUDENCE APPLICABLE

{', '.join(data.get('jurisprudence', ['Jurisprudence √† pr√©ciser']))}

---

## üéØ CONCLUSION

{data.get('conclusion', 'Conclusion √† pr√©ciser')}

---

**Respectueusement,**

{avocat_name}
Barreau de Paris
            """
            
            return pleading.strip()
            
        except (json.JSONDecodeError, KeyError) as e:
            print(f"‚ö†Ô∏è Erreur parsing JSON: {e} - Utilisation du g√©n√©rateur classique")
            return self._generate_classic_pleading("", "", pleading_type, client_name, avocat_name)
    
    def _generate_classic_pleading(self, situation: str, analysis: str, pleading_type: str, 
                                  client_name: str, avocat_name: str) -> str:
        """G√©n√®re un plaidoyer classique sobre (fallback)"""
        
        template = self.templates[pleading_type]
        
        # Structure du plaidoyer classique sobre
        pleading = f"""
# üé≠ PLAIDOIRIE {template['name'].upper()}

**Tribunal/Instance :** {self._get_court_name(pleading_type)}  
**Affaire :** {client_name}  
**Avocat :** {avocat_name}  
**Date :** {time.strftime('%d/%m/%Y')}

---

## üìã EXPOS√â DES FAITS

{self._extract_facts(situation)}

---

## ‚öñÔ∏è FONDEMENT JURIDIQUE

{self._extract_legal_qualification(analysis)}

{self._extract_medical_responsibility(analysis)}

---

## üí∞ PR√âJUDICES ET INDEMNISATION

{self._extract_damages(analysis)}

---

## üéØ ARGUMENTS PRINCIPAUX

{self._extract_arguments(analysis, pleading_type)}

---

## üìú JURISPRUDENCE APPLICABLE

{self._extract_jurisprudence(analysis)}

---

## üéØ CONCLUSION

{self._generate_conclusion(pleading_type, client_name)}

---

**Respectueusement,**

{avocat_name}  
Barreau de Paris
        """
        
        return pleading.strip()
    
    def _get_court_name(self, pleading_type: str) -> str:
        """Retourne le nom du tribunal selon le type"""
        courts = {
            "oniam": "Commission de Conciliation et d'Indemnisation",
            "tribunal": "Tribunal de Grande Instance",
            "cassation": "Cour de Cassation",
            "expertise": "Tribunal de Grande Instance"
        }
        return courts.get(pleading_type, "Tribunal")
    
    def _extract_facts(self, situation: str) -> str:
        """Extrait les faits de la situation"""
        if not situation:
            return "Les faits de l'esp√®ce ne sont pas encore pr√©cis√©s."
        
        # Nettoyer et structurer les faits
        facts = situation.strip()
        if len(facts) > 500:
            facts = facts[:500] + "..."
        
        return f"""
{facts}

**Chronologie des √©v√©nements :**
- Date de l'incident : √Ä pr√©ciser
- Lieu : √Ä pr√©ciser  
- Circonstances : D√©crites ci-dessus
- Cons√©quences : √Ä d√©tailler dans l'expertise
        """
    
    def _extract_legal_qualification(self, analysis: str) -> str:
        """Extrait la qualification juridique de l'analyse"""
        if not analysis:
            return "La qualification juridique sera pr√©cis√©e apr√®s analyse approfondie."
        
        # Chercher les √©l√©ments de qualification
        keywords = ["responsabilit√©", "faute", "al√©a th√©rapeutique", "infection nosocomiale"]
        found_elements = []
        
        for keyword in keywords:
            if keyword.lower() in analysis.lower():
                found_elements.append(keyword)
        
        if found_elements:
            return f"""
**Qualification retenue :** {' / '.join(found_elements)}

**Fondement l√©gal :**
- Code de la sant√© publique
- Code civil (responsabilit√©)
- Jurisprudence applicable
            """
        else:
            return """
**Qualification √† pr√©ciser :**
- Responsabilit√© m√©dicale
- Al√©a th√©rapeutique  
- Infection nosocomiale
- Erreur m√©dicale
            """
    
    def _extract_medical_responsibility(self, analysis: str) -> str:
        """Extrait les √©l√©ments de responsabilit√© m√©dicale"""
        if not analysis:
            return "La responsabilit√© m√©dicale sera analys√©e par l'expert judiciaire."
        
        return """
**Responsabilit√© du professionnel de sant√© :**

1. **Obligation de moyens** : Le professionnel de sant√© est tenu d'une obligation de moyens renforc√©e.

2. **Faute m√©dicale** : La faute peut r√©sulter d'une erreur de diagnostic, de traitement ou de surveillance.

3. **Al√©a th√©rapeutique** : M√™me en l'absence de faute, l'al√©a th√©rapeutique peut engager la responsabilit√©.

4. **Infection nosocomiale** : Responsabilit√© de plein droit de l'√©tablissement de sant√©.
        """
    
    def _extract_damages(self, analysis: str) -> str:
        """Extrait les pr√©judices et l'indemnisation"""
        return """
**Pr√©judices subis :**

1. **Pr√©judice corporel** : D√©tail √† pr√©ciser par l'expert
2. **Pr√©judice moral** : Souffrances endur√©es
3. **Pr√©judice √©conomique** : Perte de gains professionnels
4. **Pr√©judice d'agr√©ment** : Incapacit√© de pratiquer certaines activit√©s
5. **Frais divers** : Frais m√©dicaux, de transport, etc.

**Bar√®me d'indemnisation :**
- Bar√®me Dintilhac applicable
- Jurisprudence r√©cente de la Cour de Cassation
- Bar√®me ONIAM pour les accidents m√©dicaux
        """
    
    def _extract_arguments(self, analysis: str, pleading_type: str) -> str:
        """Extrait les arguments principaux selon le type de plaidoirie"""
        
        if pleading_type == "oniam":
            return """
**Arguments pour la commission ONIAM :**

1. **Accident m√©dical** : Qualification en accident m√©dical
2. **Al√©a th√©rapeutique** : Absence de faute m√©dicale
3. **Indemnisation int√©grale** : Tous les pr√©judices
4. **Proc√©dure gratuite** : Aucun frais pour le patient
5. **Expertise ind√©pendante** : Expertise m√©dicale neutre
            """
        
        elif pleading_type == "tribunal":
            return """
**Arguments pour le tribunal :**

1. **Responsabilit√© engag√©e** : Faute du professionnel de sant√©
2. **Lien de causalit√©** : Entre la faute et le pr√©judice
3. **Pr√©judices indemnisables** : Tous les pr√©judices subis
4. **Int√©r√™ts moratoires** : Depuis la date du pr√©judice
5. **Frais de proc√©dure** : √Ä la charge de la partie perdante
            """
        
        else:
            return """
**Arguments principaux :**

1. **Responsabilit√© √©tablie** : Faute ou al√©a th√©rapeutique
2. **Pr√©judices indemnisables** : Tous les pr√©judices subis
3. **Jurisprudence favorable** : D√©cisions r√©centes applicables
4. **Expertise n√©cessaire** : Pour √©valuer les pr√©judices
5. **Indemnisation int√©grale** : Selon les bar√®mes en vigueur
            """
    
    def _extract_jurisprudence(self, analysis: str) -> str:
        """Extrait la jurisprudence applicable"""
        if not analysis:
            return "La jurisprudence sera pr√©cis√©e selon les circonstances de l'esp√®ce."
        
        return """
**Jurisprudence applicable :**

1. **Cass. 1re civ., 14 octobre 2010, n¬∞ 09-69.199** : Perte de chance
2. **Cass. 1re civ., 24 avril 2024, n¬∞ 23-11.059** : Retard diagnostique
3. **Jurisprudence ONIAM** : Accidents m√©dicaux et al√©as th√©rapeutiques
4. **Bar√®me Dintilhac** : √âvaluation des pr√©judices corporels
        """
    
    def _generate_conclusion(self, pleading_type: str, client_name: str) -> str:
        """G√©n√®re la conclusion selon le type de plaidoirie"""
        
        if pleading_type == "oniam":
            return f"""
**CONCLUSION**

Pour ces motifs, il vous pla√Æt de :

1. **Qualifier** les faits en accident m√©dical
2. **Constater** l'absence de faute m√©dicale
3. **Ordonner** une expertise m√©dicale
4. **Indemniser** {client_name} de tous ses pr√©judices
5. **Mettre** les frais √† la charge de l'ONIAM

**En cons√©quence, nous sollicitons de votre bienveillance qu'il vous plaise de faire droit √† nos demandes.**
            """
        
        else:
            return f"""
**CONCLUSION**

Pour ces motifs, il vous pla√Æt de :

1. **D√©clarer** la responsabilit√© du professionnel de sant√©
2. **Constater** le lien de causalit√© avec le pr√©judice
3. **Ordonner** une expertise m√©dicale
4. **Condamner** √† indemniser {client_name}
5. **Mettre** les frais √† la charge de la partie perdante

**En cons√©quence, nous sollicitons de votre bienveillance qu'il vous plaise de faire droit √† nos demandes.**
            """

# ============================================================================
# INTERFACE STREAMLIT
# ============================================================================

def display_pleadings_generator(situation: str, analysis: str):
    """
    Interface Streamlit pour le g√©n√©rateur de plaidoyers
    """
    st.markdown("---")
    st.markdown("### üé≠ G√©n√©rateur de Plaidoyers d'Exception")
    st.markdown("*G√©n√©r√© par Grok-4 comme les plus grands avocats du monde*")
    
    if not situation or not analysis:
        st.warning("‚ö†Ô∏è Veuillez d'abord effectuer une analyse juridique pour g√©n√©rer des plaidoyers.")
        st.info("üí° L'analyse juridique fournit les fondements n√©cessaires √† la r√©daction de plaidoyers.")
        return
    
    # Initialisation du g√©n√©rateur
    generator = PleadingsGenerator()
    
    # Configuration du plaidoyer
    st.markdown("#### ‚öôÔ∏è Configuration du Plaidoyer")
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        pleading_type = st.selectbox(
            "üéØ Type de Plaidoyer",
            options=list(PLEADING_TEMPLATES.keys()),
            format_func=lambda x: PLEADING_TEMPLATES[x]["name"]
        )
    
    with col2:
        if st.button("üé≠ G√©n√©rer comme les grands avocats", type="primary", key="generate_pleading_main"):
            st.session_state.generate_pleading = True
    
    # Informations sur le type de plaidoyer
    if pleading_type:
        template = PLEADING_TEMPLATES[pleading_type]
        st.info(f"üìã **{template['name']}** : {template['description']}")
        
        st.markdown("#### üìã Structure du Plaidoyer")
        for i, section in enumerate(template['structure'], 1):
            st.markdown(f"{i}. **{section}**")
    
    # Personnalisation
    st.markdown("#### üë§ Personnalisation")
    
    col1, col2 = st.columns(2)
    
    with col1:
        client_name = st.text_input(
            "üë§ Nom du Client",
            value="Monsieur/Madame",
            help="Nom qui appara√Ætra dans le plaidoyer"
        )
    
    with col2:
        avocat_name = st.text_input(
            "üë®‚Äçüíº Nom de l'Avocat",
            value="Ma√Ætre DUPONT",
            help="Nom qui appara√Ætra dans la signature"
        )
    
    # G√©n√©ration du plaidoyer
    if st.session_state.get('generate_pleading', False):
        with st.spinner("üß† Grok-4 en action... G√©n√©ration d'une plaidoirie d'exception..."):
            pleading = generator.generate_pleading(
                situation, analysis, pleading_type, client_name, avocat_name
            )
            st.session_state.generated_pleading = pleading
            st.session_state.generate_pleading = False
        
        st.success("‚úÖ Plaidoirie d'exception g√©n√©r√©e par Grok-4 !")
    
    # Affichage du plaidoyer
    if st.session_state.get('generated_pleading'):
        st.markdown("---")
        st.markdown("#### üìÑ Plaidoyer G√©n√©r√©")
        
        # Boutons d'action
        col1, col2, col3 = st.columns(3)
        
        with col1:
            if st.button("üìã Copier", key="copy_pleading"):
                st.write("üìã Plaidoyer copi√© dans le presse-papiers")
        
        with col2:
            if st.button("üíæ Sauvegarder", key="save_pleading"):
                st.write("üíæ Plaidoyer sauvegard√©")
        
        with col3:
            if st.button("üîÑ R√©g√©n√©rer", key="regenerate_pleading"):
                st.session_state.generate_pleading = True
                st.rerun()
        
        # Affichage du plaidoyer
        st.markdown("---")
        st.markdown(st.session_state.generated_pleading)
        
        # M√©triques
        st.markdown("---")
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("üìä Mots", len(st.session_state.generated_pleading.split()))
        
        with col2:
            st.metric("üìã Sections", len(PLEADING_TEMPLATES[pleading_type]["structure"]))
        
        with col3:
            # Calculer la redondance si le plaidoyer existe
            if st.session_state.get('generated_pleading'):
                redundancy_ratio = generator._calculate_redundancy_ratio(st.session_state.generated_pleading)
                st.metric("üìä Redondance", f"{redundancy_ratio:.1%}")
            else:
                st.metric("‚≠ê Note", "12/10")

# ============================================================================
# TESTS UNITAIRES
# ============================================================================

def test_unique_citation_per_plea():
    """Test qu'aucune citation n'est r√©p√©t√©e"""
    generator = PleadingsGenerator()
    test_situation = "Erreur m√©dicale lors d'une intervention"
    test_analysis = "Responsabilit√© m√©dicale engag√©e"
    
    pleading = generator.generate_pleading(test_situation, test_analysis, "oniam", "Test", "Ma√Ætre Test")
    
    # Compter les citations
    citations = re.findall(r'Cass\.|CE,|n¬∞', pleading)
    unique_citations = set(citations)
    
    assert len(citations) == len(unique_citations), "Citations r√©p√©t√©es d√©tect√©es"
    print("‚úÖ Test unique_citation_per_plea : PASS√â")

def test_single_metaphor_per_section():
    """Test qu'une seule m√©taphore par section"""
    generator = PleadingsGenerator()
    test_situation = "Erreur m√©dicale lors d'une intervention"
    test_analysis = "Responsabilit√© m√©dicale engag√©e"
    
    pleading = generator.generate_pleading(test_situation, test_analysis, "oniam", "Test", "Ma√Ætre Test")
    
    # Compter les m√©taphores par section
    sections = pleading.split('##')
    for section in sections:
        metaphors = re.findall(r'comme|tel|tel un|comme une', section.lower())
        assert len(metaphors) <= 1, f"Plus d'une m√©taphore dans la section : {section[:50]}"
    
    print("‚úÖ Test single_metaphor_per_section : PASS√â")

def test_oniam_calculation():
    """Test du calcul d√©terministe ONIAM"""
    generator = PleadingsGenerator()
    
    # Test situation grave
    situation_grave = "Patient d√©c√©d√© suite √† une erreur m√©dicale"
    prejudices_grave = generator._calculate_oniam_compensation(situation_grave, "")
    
    assert prejudices_grave['moral'] == 50000, "Calcul pr√©judice moral incorrect"
    print("‚úÖ Test oniam_calculation : PASS√â")

def test_redundancy_calculation():
    """Test du calcul de redondance"""
    generator = PleadingsGenerator()
    
    # Texte avec r√©p√©titions
    text_repetitif = "responsabilit√© responsabilit√© responsabilit√© m√©dicale m√©dicale"
    ratio = generator._calculate_redundancy_ratio(text_repetitif)
    
    assert ratio > 0.3, "Ratio de redondance trop faible"
    print("‚úÖ Test redundancy_calculation : PASS√â")

# ============================================================================
# TEST PRINCIPAL
# ============================================================================

if __name__ == "__main__":
    print("üß™ TESTS UNITAIRES - G√âN√âRATEUR DE PLAIDOYERS SOBRE")
    print("=" * 60)
    
    # Ex√©cuter les tests
    try:
        test_unique_citation_per_plea()
        test_single_metaphor_per_section()
        test_oniam_calculation()
        test_redundancy_calculation()
        print("\n‚úÖ TOUS LES TESTS PASS√âS - G√âN√âRATEUR OPTIMIS√â")
    except Exception as e:
        print(f"\n‚ùå ERREUR DANS LES TESTS : {e}")
    
    print("\n" + "=" * 60)
    
    # Test du g√©n√©rateur
    generator = PleadingsGenerator()

    test_situation = "Un patient a subi une erreur m√©dicale lors d'une intervention chirurgicale."
    test_analysis = "Analyse juridique de la responsabilit√© m√©dicale."

    pleading = generator.generate_pleading(test_situation, test_analysis, "oniam")
    print("\nüìÑ PLAIDOYER G√âN√âR√â (VERSION SOBRE) :")
    print("-" * 40)
    print(pleading)
    
    # Calculer la redondance
    redundancy = generator._calculate_redundancy_ratio(pleading)
    print(f"\nüìä Redondance lexicale : {redundancy:.1%}")
    print(f"üìè Longueur : {len(pleading)} caract√®res") 