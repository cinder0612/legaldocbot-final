"""
G√©n√©rateur de timeline interactive pour LegalDocBot
Extrait et visualise les √©v√©nements chronologiques d'une situation m√©dicale
"""

import streamlit as st
import re
from datetime import datetime, date
from typing import Dict, List, Optional, Tuple
import plotly.figure_factory as ff
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# ============================================================================
# EXTRACTION D'√âV√âNEMENTS CHRONOLOGIQUES
# ============================================================================

def extract_timeline_events(situation: str) -> List[Dict]:
    """
    Extrait les √©v√©nements chronologiques d'une situation m√©dicale
    """
    events = []
    
    # Patterns pour d√©tecter les dates
    date_patterns = [
        r'(\d{1,2})/(\d{1,2})/(\d{4})',  # DD/MM/YYYY
        r'(\d{1,2})-(\d{1,2})-(\d{4})',  # DD-MM-YYYY
        r'(\d{1,2})\.(\d{1,2})\.(\d{4})', # DD.MM.YYYY
        r'le (\d{1,2})/(\d{1,2})/(\d{4})', # le DD/MM/YYYY
        r'(\d{1,2})/(\d{1,2})/(\d{2})',   # DD/MM/YY
    ]
    
    # Patterns pour d√©tecter les √©v√©nements m√©dicaux
    medical_keywords = [
        'consultation', 'hospitalisation', 'op√©ration', 'chirurgie', 'diagnostic',
        'examen', 'analyse', 'radiographie', 'scanner', 'IRM', '√©chographie',
        'traitement', 'm√©dicament', 'douleur', 'sympt√¥me', 'aggravation',
        'am√©lioration', 'gu√©rison', 'd√©c√®s', 'complication', 'erreur m√©dicale'
    ]
    
    # Patterns pour d√©tecter les √©v√©nements juridiques
    legal_keywords = [
        'plainte', 'd√©p√¥t', 'expertise', 'commission', 'CCI', 'CDU', 'ONIAM',
        'tribunal', 'cour', 'jugement', 'arr√™t', 'd√©cision', 'conciliation',
        'm√©diation', 'proc√©dure', 'prescription', 'd√©lai'
    ]
    
    # Extraction des dates et √©v√©nements
    for pattern in date_patterns:
        matches = re.finditer(pattern, situation, re.IGNORECASE)
        for match in matches:
            try:
                if len(match.groups()) == 3:
                    day, month, year = match.groups()
                    if len(year) == 2:
                        year = '20' + year
                    
                    event_date = datetime(int(year), int(month), int(day))
                    
                    # Recherche du contexte autour de la date
                    start_pos = max(0, match.start() - 100)
                    end_pos = min(len(situation), match.end() + 100)
                    context = situation[start_pos:end_pos]
                    
                    # Classification de l'√©v√©nement
                    event_type = "other"
                    event_category = "√âv√©nement"
                    
                    # V√©rification des mots-cl√©s m√©dicaux
                    for keyword in medical_keywords:
                        if keyword.lower() in context.lower():
                            event_type = "medical"
                            event_category = "M√©dical"
                            break
                    
                    # V√©rification des mots-cl√©s juridiques
                    for keyword in legal_keywords:
                        if keyword.lower() in context.lower():
                            event_type = "legal"
                            event_category = "Juridique"
                            break
                    
                    # Cr√©ation de l'√©v√©nement
                    event = {
                        'date': event_date,
                        'date_str': match.group(),
                        'context': context.strip(),
                        'type': event_type,
                        'category': event_category,
                        'description': extract_event_description(context)
                    }
                    
                    events.append(event)
                    
            except (ValueError, TypeError):
                continue
    
    # Tri par date
    events.sort(key=lambda x: x['date'])
    
    return events

def extract_event_description(context: str) -> str:
    """
    Extrait une description concise de l'√©v√©nement
    """
    # Nettoyage du contexte
    context = re.sub(r'\s+', ' ', context).strip()
    
    # Recherche de phrases compl√®tes
    sentences = re.split(r'[.!?]', context)
    
    for sentence in sentences:
        sentence = sentence.strip()
        if len(sentence) > 10 and len(sentence) < 200:
            return sentence
    
    # Si pas de phrase compl√®te, retourner le contexte tronqu√©
    return context[:100] + "..." if len(context) > 100 else context

# ============================================================================
# G√âN√âRATION DE TIMELINE INTERACTIVE
# ============================================================================

def create_interactive_timeline(events: List[Dict]) -> go.Figure:
    """
    Cr√©e une timeline interactive avec Plotly
    """
    if not events:
        # Timeline vide
        fig = go.Figure()
        fig.add_annotation(
            text="Aucun √©v√©nement chronologique d√©tect√©",
            xref="paper", yref="paper",
            x=0.5, y=0.5, showarrow=False,
            font=dict(size=16, color="gray")
        )
        fig.update_layout(
            title="Timeline des √âv√©nements",
            xaxis_title="Date",
            yaxis_title="√âv√©nements",
            height=400
        )
        return fig
    
    # Pr√©paration des donn√©es
    dates = [event['date'] for event in events]
    descriptions = [event['description'] for event in events]
    categories = [event['category'] for event in events]
    colors = []
    
    # Couleurs selon le type d'√©v√©nement
    for event in events:
        if event['type'] == 'medical':
            colors.append('#1f77b4')  # Bleu pour m√©dical
        elif event['type'] == 'legal':
            colors.append('#ff7f0e')  # Orange pour juridique
        else:
            colors.append('#2ca02c')  # Vert pour autres
    
    # Cr√©ation de la timeline
    fig = go.Figure()
    
    # Ajout des √©v√©nements
    for i, (date, desc, category, color) in enumerate(zip(dates, descriptions, categories, colors)):
        fig.add_trace(go.Scatter(
            x=[date],
            y=[i],
            mode='markers+text',
            marker=dict(
                size=15,
                color=color,
                symbol='circle'
            ),
            text=[f"{category}"],
            textposition="top center",
            name=category,
            hovertemplate=f"<b>{date.strftime('%d/%m/%Y')}</b><br>{desc}<extra></extra>",
            showlegend=False
        ))
    
    # Mise en forme
    fig.update_layout(
        title="üìÖ Timeline des √âv√©nements",
        xaxis_title="Date",
        yaxis_title="√âv√©nements",
        height=400,
        hovermode='closest',
        xaxis=dict(
            tickformat='%d/%m/%Y',
            tickmode='auto',
            nticks=min(10, len(events))
        ),
        yaxis=dict(
            showticklabels=False,
            range=[-0.5, len(events) - 0.5]
        ),
        margin=dict(l=50, r=50, t=80, b=50)
    )
    
    return fig

def create_gantt_chart(events: List[Dict]) -> go.Figure:
    """
    Cr√©e un diagramme de Gantt pour les √©v√©nements
    """
    if not events:
        return create_interactive_timeline([])
    
    # Pr√©paration des donn√©es pour Gantt
    tasks = []
    for i, event in enumerate(events):
        tasks.append(dict(
            Task=f"√âv√©nement {i+1}",
            Start=event['date'],
            Finish=event['date'],  # √âv√©nement ponctuel
            Resource=event['category'],
            Description=event['description']
        ))
    
    # Cr√©ation du Gantt
    fig = ff.create_gantt(
        tasks,
        colors={
            'M√©dical': '#1f77b4',
            'Juridique': '#ff7f0e',
            '√âv√©nement': '#2ca02c'
        },
        index_col='Resource',
        show_colorbar=True,
        group_tasks=True,
        showgrid_x=True,
        showgrid_y=True
    )
    
    fig.update_layout(
        title="üìä Diagramme de Gantt des √âv√©nements",
        xaxis_title="Date",
        height=400,
        margin=dict(l=50, r=50, t=80, b=50)
    )
    
    return fig

# ============================================================================
# INTERFACE STREAMLIT
# ============================================================================

def display_timeline_generator(situation: str):
    """
    Interface Streamlit pour le g√©n√©rateur de timeline
    """
    st.markdown("---")
    st.markdown("### üìÖ Timeline Interactive des Faits")
    st.markdown("*Extraction automatique des √©v√©nements chronologiques*")
    
    if not situation:
        st.warning("‚ö†Ô∏è Veuillez d'abord saisir une situation pour g√©n√©rer la timeline.")
        return
    
    # Extraction des √©v√©nements
    with st.spinner("üîç Extraction des √©v√©nements chronologiques..."):
        events = extract_timeline_events(situation)
    
    # Statistiques
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("üìä √âv√©nements", len(events))
    
    with col2:
        medical_events = len([e for e in events if e['type'] == 'medical'])
        st.metric("üè• M√©dicaux", medical_events)
    
    with col3:
        legal_events = len([e for e in events if e['type'] == 'legal'])
        st.metric("‚öñÔ∏è Juridiques", legal_events)
    
    with col4:
        if events:
            date_range = f"{(max(e['date'] for e in events) - min(e['date'] for e in events)).days} jours"
            st.metric("üìÖ P√©riode", date_range)
        else:
            st.metric("üìÖ P√©riode", "N/A")
    
    # Affichage des timelines
    if events:
        # Onglets pour diff√©rents types de visualisation
        tab1, tab2 = st.tabs(["üìÖ Timeline", "üìä Gantt"])
        
        with tab1:
            st.markdown("#### Timeline Interactive")
            fig_timeline = create_interactive_timeline(events)
            st.plotly_chart(fig_timeline, use_container_width=True)
        
        with tab2:
            st.markdown("#### Diagramme de Gantt")
            fig_gantt = create_gantt_chart(events)
            st.plotly_chart(fig_gantt, use_container_width=True)
        
        # D√©tails des √©v√©nements
        with st.expander("üìã D√©tails des √âv√©nements"):
            for i, event in enumerate(events, 1):
                col1, col2 = st.columns([1, 4])
                
                with col1:
                    if event['type'] == 'medical':
                        st.markdown("üè•")
                    elif event['type'] == 'legal':
                        st.markdown("‚öñÔ∏è")
                    else:
                        st.markdown("üìÖ")
                
                with col2:
                    st.markdown(f"**{event['date'].strftime('%d/%m/%Y')}** - {event['category']}")
                    st.markdown(f"*{event['description']}*")
                
                if i < len(events):
                    st.markdown("---")
        
        # Alertes de d√©lai
        display_deadline_alerts(events)
        
    else:
        st.info("‚ÑπÔ∏è Aucun √©v√©nement chronologique d√©tect√© dans la situation.")
        st.markdown("**Conseils pour am√©liorer la d√©tection :**")
        st.markdown("- Utilisez des dates au format DD/MM/YYYY")
        st.markdown("- Mentionnez les consultations, hospitalisations, etc.")
        st.markdown("- Incluez les √©v√©nements juridiques (plaintes, expertises)")

def display_deadline_alerts(events: List[Dict]):
    """
    Affiche les alertes de d√©lai de prescription
    """
    st.markdown("---")
    st.markdown("### ‚è∞ Alertes de D√©lai")
    
    if not events:
        return
    
    # Calcul des d√©lais de prescription
    today = datetime.now()
    prescription_deadlines = {
        "Responsabilit√© m√©dicale": 10,  # 10 ans
        "Accident m√©dical": 10,        # 10 ans
        "Infection nosocomiale": 10,   # 10 ans
        "Produit d√©fectueux": 10,      # 10 ans
        "Obligation d'information": 5  # 5 ans
    }
    
    alerts = []
    
    for event in events:
        if event['type'] == 'medical':
            for deadline_type, years in prescription_deadlines.items():
                deadline_date = event['date'].replace(year=event['date'].year + years)
                days_remaining = (deadline_date - today).days
                
                if days_remaining > 0 and days_remaining <= 365:  # Alerte si moins d'1 an
                    alerts.append({
                        'type': deadline_type,
                        'event_date': event['date'],
                        'deadline_date': deadline_date,
                        'days_remaining': days_remaining,
                        'description': event['description']
                    })
    
    if alerts:
        # Tri par urgence
        alerts.sort(key=lambda x: x['days_remaining'])
        
        for alert in alerts[:3]:  # Top 3 plus urgents
            if alert['days_remaining'] <= 30:
                st.error(f"üö® **URGENT** : {alert['type']} - {alert['days_remaining']} jours restants")
            elif alert['days_remaining'] <= 90:
                st.warning(f"‚ö†Ô∏è **ATTENTION** : {alert['type']} - {alert['days_remaining']} jours restants")
            else:
                st.info(f"‚ÑπÔ∏è **RAPPEL** : {alert['type']} - {alert['days_remaining']} jours restants")
            
            st.markdown(f"*√âv√©nement d√©clencheur : {alert['description']}*")
            st.markdown(f"*Date limite : {alert['deadline_date'].strftime('%d/%m/%Y')}*")
            st.markdown("---")
    else:
        st.success("‚úÖ Aucun d√©lai de prescription critique d√©tect√©")

# ============================================================================
# FONCTIONS UTILITAIRES
# ============================================================================

def validate_date_format(date_str: str) -> bool:
    """
    Valide le format d'une date
    """
    patterns = [
        r'^\d{1,2}/\d{1,2}/\d{4}$',
        r'^\d{1,2}-\d{1,2}-\d{4}$',
        r'^\d{1,2}\.\d{1,2}\.\d{4}$'
    ]
    
    return any(re.match(pattern, date_str) for pattern in patterns)

def get_event_statistics(events: List[Dict]) -> Dict:
    """
    Calcule les statistiques des √©v√©nements
    """
    if not events:
        return {}
    
    stats = {
        'total_events': len(events),
        'medical_events': len([e for e in events if e['type'] == 'medical']),
        'legal_events': len([e for e in events if e['type'] == 'legal']),
        'other_events': len([e for e in events if e['type'] == 'other']),
        'date_range': (max(e['date'] for e in events) - min(e['date'] for e in events)).days,
        'first_event': min(e['date'] for e in events),
        'last_event': max(e['date'] for e in events)
    }
    
    return stats 